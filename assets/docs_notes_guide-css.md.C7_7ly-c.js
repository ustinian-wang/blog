import{_ as s,o as i,c as p,a5 as a}from"./chunks/framework.Cjg1mlEg.js";const _=JSON.parse('{"title":"CSS-GUIDE","description":"","frontmatter":{},"headers":[],"relativePath":"docs/notes/guide-css.md","filePath":"docs/notes/guide-css.md","lastUpdated":1723359560000}'),t={name:"docs/notes/guide-css.md"},e=a(`<h1 id="css-guide" tabindex="-1">CSS-GUIDE <a class="header-anchor" href="#css-guide" aria-label="Permalink to &quot;CSS-GUIDE&quot;">​</a></h1><p>1、文件分层：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">---base</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #屏蔽底层UI差异，原子类UI，通用UI</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-component</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #各个组件的UI</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-common</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #页面中可以共用UI</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-page</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #页面具体的业务UI</span></span></code></pre></div><p>2、命名空间隔离</p><p>意义：与第三方的插件或者框架避开UI上的冲突</p><p>命名空间-选择符：.bd-selector{}</p><p>3、命名原则</p><ol><li>单类</li><li>语义，结构（去业务化）</li><li>多用组合，少用继承</li></ol><p>4、命名</p><ol><li>列表：.bd-navList</li><li>列表项：.bd-navList-item</li><li>图片链接：.bd-imgLink</li><li>图片：.bd-img</li><li>全局容器：g_wrap</li></ol><p>5、原子类</p><p>优点：原子类可以很方便的复用，减少代码量，是一种class化的行内样式，解决style优先级过高的问题。</p><p>缺点：增加HTML的体积，在html中随着应用面的增多，它也会像style一样变得不可控，因为原子类是“类名即属性”。</p><p>解决方案：</p><p>使用通用类，比如bootstrap中的.btn .btn-primary .btn-danger，</p><p>原子类用于页面调试，.bgccc{background:#ccc;}，一来可以标记样式，二来因优先级不高，可以覆盖样式。</p><p>6、层级</p><ol><li><p>层级不能超过3层，尽量使用单类名</p></li><li><ol><li><p>使用规则如下：</p></li><li><ol><li>1层：视觉稿样式：.navList{}， .navList-item{}</li><li>2~3层：交互样式（因为交互时，有控制样式变化的需要，需要利用到层级）.navList:hover item{}， .J_show .item{}(js钩子这里只是做示例，实际开头不会是J)特别的情况下，需要用到层级，比如局部代码抽取成组件样式，组件内部，各部分都有关联的需要，避免外界的影响。</li></ol></li></ol></li><li><p>层级一般用于实现CSS交互，:hover,:check这一类具有交互效果，同时需要改变交互时的样式</p></li></ol><p>或者做一些类似皮肤效果切换的功能。</p><p>3、css再分层的话，分为表现层（.videoPanel-playBtn），交互层（:hover，:check，:target）</p><p>4、层级过多的缺点：</p><p>1）控制力太强了，样式难以覆盖</p><p>2）层级太深，理解代码费劲，费时间</p><p>3）修改层级时，难以准确定位</p><p>5、层级少的优点：</p><p>即使在不理解代码的情况下，你要定位代码非常容易，尤其是1层的时候，直接ctrl+f搜索目标类名，趴一下就找到了</p><p>7、书写顺序</p><p>display position left top right bottom margin border padding width height line-height font-size</p><p>8、OOCSS</p><p>所谓的OOCSS其实就是 .btn{} .btn-primary{}，抽取共用的css作为一个单元样式，然后类名之间命名有点关联罢了。</p>`,30),l=[e];function n(o,h,d,c,r,k){return i(),p("div",{"data-pagefind-body":!0},l)}const m=s(t,[["render",n]]);export{_ as __pageData,m as default};
