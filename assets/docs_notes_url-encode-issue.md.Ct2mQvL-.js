import{_ as e,o,c as d,a5 as c}from"./chunks/framework.Cjg1mlEg.js";const h=JSON.parse('{"title":"url encode issue","description":"","frontmatter":{},"headers":[],"relativePath":"docs/notes/url-encode-issue.md","filePath":"docs/notes/url-encode-issue.md","lastUpdated":1722787423000}'),t={name:"docs/notes/url-encode-issue.md"},p=c('<h1 id="url-encode-issue" tabindex="-1">url encode issue <a class="header-anchor" href="#url-encode-issue" aria-label="Permalink to &quot;url encode issue&quot;">​</a></h1><p>url的组成：字母、阿拉伯数值、某些标点符号。</p><p>不能使用其他文字和符号，比如希腊字母、中文等，因为网络标准RFC 1738 做了硬性规定：</p><p>只有字母和数字[0-9a-zA-Z]、一些特殊符号“$-_.+!*&#39;(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于 URL。</p><p>如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致“URL编码”成为了一个混乱的领域。</p><p><strong>情况1：网址路径包含中文</strong></p><p><a href="http://zh.wikipedia.org/wiki/%E6%98%A5%E8%8A%82" target="_blank" rel="noreferrer">http://zh.wikipedia.org/wiki/春节</a></p><p>网址路径的编码，用的是utf-8编码。</p><p><strong>情况2：查询字符包含汉字</strong></p><p><a href="http://www.baidu.com/s?wd=%E6%98%A5%E8%8A%82" target="_blank" rel="noreferrer">http://www.baidu.com/s?wd=春节</a></p><p>查询字符串的编码，用的是操作系统的默认编码</p><p><strong>情况3：Get方法生成的URL包含汉字</strong></p><p>前面说的是直接输入网址的情况，但是更常见的情况是，在已打开的网页上，直接用Get或Post方法发出HTTP请求。</p><p>根据台湾中兴大学吕瑞麟老师的试验 ，这时的编码方法由网页的编码决定，也就是由HTML源码中字符集的设定决定。</p><p>GET和POST方法的编码，用的是网页的编码。</p><p><strong>情况4：Ajax调用的URL包含汉字</strong></p><p>在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是 采用utf-8编码。</p><p>JS函数：</p><ul><li><p><code>escape()</code>: 它的真正作用是返回一个字符的Unicode编码值</p><ol><li>除了ASCII字母、数字、标点符号<code>@ * _ + - . /</code>之外，对其他所有字符进行编码。</li><li>在<code>/u0000</code>到<code>/u00ff</code>之间的符号被转成<code>%xx</code>的形式，其余符号被转成<code>%uxxxx</code>的形式。</li><li>不对<code>+</code>编码。但是在提交表单时，空格会被转化为<code>+</code>字符。</li></ol></li><li><p><code>encodeURI()</code>: 它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号<code>;/?:@&amp;=+$,#</code>也不进行编码。编码后，它输出符号的utf-8形式，并在每个字节前加上<code>%</code>。</p></li><li><p><code>encodeURIComponent()</code>: 它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。因此，<code>;/?:@&amp;=+$,#</code>这些在<code>encodeURI()</code>中不被编码的符号，在<code>encodeURIComponent()</code>中统统会被编码。至于具体的编码方法，两者是一样的。</p></li></ul><p>总结：</p><ol><li>前端发送请求的时候，中文和一些其他特殊字符不能直接放到URL上，必须转成unicode值，再放上去，而后端拿到的URL，还需要把特定的unicode值转成正常的内容，方便使用。不这样做的话，前后端通信的内容就会乱码。</li><li>前端如果转码，那么后端便需要解码，反之亦然。</li></ol>',21),r=[p];function s(i,a,n,l,u,_){return o(),d("div",{"data-pagefind-body":!0},r)}const R=e(t,[["render",s]]);export{h as __pageData,R as default};
