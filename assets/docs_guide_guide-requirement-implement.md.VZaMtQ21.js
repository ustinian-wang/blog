import{_ as a,o as e,c as t,a5 as r}from"./chunks/framework.Cjg1mlEg.js";const i="/blog/assets/IMG-20240824145637181.BZwfHJim.png",o="/blog/assets/IMG-20240824152236945.DxCle3HX.png",l="/blog/assets/IMG-20240824151928820.DhnDZqYX.png",d="/blog/assets/IMG-20240824152617264.jlYvdnjJ.png",g=JSON.parse('{"title":"需求实现指南","description":"","frontmatter":{},"headers":[],"relativePath":"docs/guide/guide-requirement-implement.md","filePath":"docs/guide/guide-requirement-implement.md","lastUpdated":1725602597000}'),h={name:"docs/guide/guide-requirement-implement.md"},n=r('<h1 id="需求实现指南" tabindex="-1">需求实现指南 <a class="header-anchor" href="#需求实现指南" aria-label="Permalink to &quot;需求实现指南&quot;">​</a></h1><h2 id="背景介绍" tabindex="-1">背景介绍 <a class="header-anchor" href="#背景介绍" aria-label="Permalink to &quot;背景介绍&quot;">​</a></h2><p>针对需求实现经常出现的问题做一个汇总，输出规范减少错误率，重点在于减少，而非100%没有问题，因为0缺陷的情况是非常难以达到的。</p><h2 id="重构类" tabindex="-1">重构类 <a class="header-anchor" href="#重构类" aria-label="Permalink to &quot;重构类&quot;">​</a></h2><p>例如将A页面重构为B页面，两个页面功能是相同，但具体使用的组件，UI可能不一样，常出现的问题及解决方案如下：</p><h3 id="迁移功能点遗漏" tabindex="-1">迁移功能点遗漏 <a class="header-anchor" href="#迁移功能点遗漏" aria-label="Permalink to &quot;迁移功能点遗漏&quot;">​</a></h3><p>开发需求前出具功能对比表，对比新旧差异，例如</p><p><img src="'+i+'" alt=""></p><p>对于差异的处理方式默认如下</p><table tabindex="0"><thead><tr><th></th><th>旧版</th><th>新版</th><th>处理策略</th></tr></thead><tbody><tr><td>功能1</td><td>有</td><td>无</td><td>同步到新版</td></tr><tr><td>功能2</td><td>无</td><td>有</td><td>默认屏蔽入口，无法屏蔽时，丢出来讨论</td></tr></tbody></table><h3 id="性能比之前差" tabindex="-1">性能比之前差 <a class="header-anchor" href="#性能比之前差" aria-label="Permalink to &quot;性能比之前差&quot;">​</a></h3><p>借助第三方工具对性能进行指标打分，逐个优化，对比指标，具体详见 <a href="./../notes/optimize-page-performance.html">optimize-page-performance</a></p><h2 id="新需求" tabindex="-1">新需求 <a class="header-anchor" href="#新需求" aria-label="Permalink to &quot;新需求&quot;">​</a></h2><h3 id="功能实现遗漏" tabindex="-1">功能实现遗漏 <a class="header-anchor" href="#功能实现遗漏" aria-label="Permalink to &quot;功能实现遗漏&quot;">​</a></h3><p>通过脑图，excel等工具对需求点进行穷举，具体到文本内容，字号大小的粒度，并且研发完成后每个点自己过下。</p><p><img src="'+o+'" alt=""></p><h3 id="交互行为有争议" tabindex="-1">交互行为有争议 <a class="header-anchor" href="#交互行为有争议" aria-label="Permalink to &quot;交互行为有争议&quot;">​</a></h3><ul><li>检查是否和现有业务规范一致？ <ul><li>一致：按照现有规范，</li><li>不一致：反之交给PM和设计决定，统一规范，并同步到相关的<strong>业务交互规范文档</strong>和<strong>组件</strong></li></ul></li></ul><h3 id="ui不符合设计稿" tabindex="-1">UI不符合设计稿 <a class="header-anchor" href="#ui不符合设计稿" aria-label="Permalink to &quot;UI不符合设计稿&quot;">​</a></h3><p>把设计稿和实现效果截图，通过<a href="https://www.diffchecker.com/image-compare/" target="_blank" rel="noreferrer">在线图片对比工具</a>进行对比，这样可以快速发现UI细节问题，不用浪费设计师的时间</p><p><img src="'+l+'" alt=""></p><h3 id="提测缺陷数量多于预期" tabindex="-1">提测缺陷数量多于预期 <a class="header-anchor" href="#提测缺陷数量多于预期" aria-label="Permalink to &quot;提测缺陷数量多于预期&quot;">​</a></h3><h4 id="抄别人的作业" tabindex="-1">抄别人的作业 <a class="header-anchor" href="#抄别人的作业" aria-label="Permalink to &quot;抄别人的作业&quot;">​</a></h4><p>开发功能A的时候，看其他业务是否有开发过，去翻一下他们的需求单和缺陷单，看能否通过历史缺陷单复现缺陷，提前修复。</p><h4 id="多花点时间自测" tabindex="-1">多花点时间自测 <a class="header-anchor" href="#多花点时间自测" aria-label="Permalink to &quot;多花点时间自测&quot;">​</a></h4><p>对有交互点的地方，进行穷举，形成一个n x n的表，逐个自测</p><p><img src="'+d+'" alt=""></p><p>例如在一个界面有A，B两个按钮有4个情况：</p><ul><li>单独点击A</li><li>单独点击B</li><li>先点击A，再点击B</li><li>先点击B，再点击A</li></ul><p>我们并不需要每个可能的分支都实际操作下，但可以在脑子想下，如果按照表描述的先A后B，有没有可能出问题，然后再去测试，这样子可以提前发现问题。</p><p>上图的红色部分，就是通过这样的方式发现缺陷的。一个红色等同1个缺陷，这样自测阶段提前发现22个缺陷。</p><p>当然可能存在3个按钮A,B,C，用户可能是在BAC的操作路径下出问题，那是否要考虑呢，其实不需要，从收益的角度看，只测试两个动作的先后顺序，已经能发现大部分的缺陷，再往下收益边际递减。</p><h4 id="自测时间不足" tabindex="-1">自测时间不足 <a class="header-anchor" href="#自测时间不足" aria-label="Permalink to &quot;自测时间不足&quot;">​</a></h4><p>我们仍然可按照上面的执行，最多删减测试的内容，只要能发现超过1个缺陷，这件事就是有意义的。</p>',34),s=[n];function p(c,m,u,b,_,q){return e(),t("div",{"data-pagefind-body":!0},s)}const x=a(h,[["render",p]]);export{g as __pageData,x as default};
