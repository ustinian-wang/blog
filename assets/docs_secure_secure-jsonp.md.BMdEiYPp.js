import{_ as a,o as t,c as s,a5 as e}from"./chunks/framework.Cjg1mlEg.js";const j=JSON.parse('{"title":"jsonP漏洞","description":"","frontmatter":{},"headers":[],"relativePath":"docs/secure/secure-jsonp.md","filePath":"docs/secure/secure-jsonp.md","lastUpdated":1734972850000}'),o={name:"docs/secure/secure-jsonp.md"},n=e('<h1 id="jsonp漏洞" tabindex="-1">jsonP漏洞 <a class="header-anchor" href="#jsonp漏洞" aria-label="Permalink to &quot;jsonP漏洞&quot;">​</a></h1><h2 id="什么是jsonp" tabindex="-1">什么是jsonP <a class="header-anchor" href="#什么是jsonp" aria-label="Permalink to &quot;什么是jsonP&quot;">​</a></h2><p>json是一种通过动态创建script标签实现跨域请求资源的解决方案，基本原理就是利用了html标签不会受到同源策略的影响，绕过同源策略获取远程资源。</p><h2 id="jsonp漏洞-1" tabindex="-1">jsonP漏洞 <a class="header-anchor" href="#jsonp漏洞-1" aria-label="Permalink to &quot;jsonP漏洞&quot;">​</a></h2><h3 id="json劫持" tabindex="-1">json劫持 <a class="header-anchor" href="#json劫持" aria-label="Permalink to &quot;json劫持&quot;">​</a></h3><p>如login.b.com网站提供的json格式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>data_kt({    newAcct: &quot;boss@zhuanye02&quot;    nickname: &quot;Carry???&quot;    phoneAcct: &quot;&quot;    qqAcct: &quot;&quot;    sacct: &quot;boss&quot;    sid: 1})</span></span></code></pre></div><p>假设用户已经登录了login.b.com网站，攻击者通过一些图片或者链接诱惑用户进入第三方网站a.com，a.com网站就可以利用以下代码获取了用户的登录信息：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;script&gt;    function data_kt(obj){        alert(obj);    }    &lt;/script&gt;&lt;script src=&quot;http://login.b.com/ajax/getAcctInfo_h.do?callback=data_kt&quot;&gt;&lt;/script&gt;</span></span></code></pre></div><h3 id="jsonp引起的xss问题" tabindex="-1">jsonP引起的xss问题 <a class="header-anchor" href="#jsonp引起的xss问题" aria-label="Permalink to &quot;jsonP引起的xss问题&quot;">​</a></h3><p>jsonP为了方便前端调用，callback参数一般都是可自定义的，也是这个可定义的callback名输出又导致了其他安全问题。</p><p>在早期 jsonP 出现时候，大家都没有合格的编码习惯。再输出 jsonP 时，没有严格定义好 Content-Type（ Content-Type: application/json ），误将Content-Type进行设置为text/html等，然后加上 callback 这个输出点没有进行过滤直接导致了一个典型的 XSS 漏洞。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;script src=&quot;http://127.0.0.1/getUsers.php?callback=&lt;script&gt;alert(/xss/)&lt;/script&gt;&quot;&gt;&lt;/script&gt;</span></span></code></pre></div><h2 id="jsonp安全问题的防御" tabindex="-1">jsonP安全问题的防御 <a class="header-anchor" href="#jsonp安全问题的防御" aria-label="Permalink to &quot;jsonP安全问题的防御&quot;">​</a></h2><h3 id="json劫持的防御" tabindex="-1">json劫持的防御 <a class="header-anchor" href="#json劫持的防御" aria-label="Permalink to &quot;json劫持的防御&quot;">​</a></h3><p>JSON 劫持的防御，重点其实就在于对调用方没有进行验证，那么对应的防御措施就比如：</p><p>● 验证referer，也就是验证调用方；</p><p>● 增加随机Token。</p><h3 id="对产生xss问题的防御" tabindex="-1">对产生xss问题的防御 <a class="header-anchor" href="#对产生xss问题的防御" aria-label="Permalink to &quot;对产生xss问题的防御&quot;">​</a></h3><p>对于XSS问题，我们从原理入手，最主要的就是：</p><p>● 设置正确的Content-Type；</p><p>● 可以通过对callback函数的长度进行限制、内容进行特殊字符的过滤，这块可以参考XSS的防御方法。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>1.  严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。</p><p>2.  严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。</p><p>3.  严格过滤 callback 函数名及 JSON 里数据的输出。</p><p>4.  严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。</p><p>5.  其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听说在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。</p>',28),c=[n];function p(l,i,r,h,d,u){return t(),s("div",{"data-pagefind-body":!0},c)}const k=a(o,[["render",p]]);export{j as __pageData,k as default};
